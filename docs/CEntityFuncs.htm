<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	<meta name="generator" content="ASDocGenerator 1.1">
	<meta name="description" content="Global entity functions">
	<meta property="og:title" content="CEntityFuncs">
	<meta property="og:description" content="Global entity functions">
	<meta property="og:type" content="website">
	<meta property="og:image" content="https://github.com/baso88/SC_AngelScript/wiki/images/sc_as_logo_media.png">
	<meta property="og:site_name" content="Sven Co-op AngelScript API">
	<link rel="stylesheet" type="text/css" href="doc.css">
	<title>CEntityFuncs</title>
</head>
<body>
	<h1>CEntityFuncs</h1>
	<p>Global entity functions</p>
	<p><b>Type:</b> Reference type</p>
	<div><h2>Methods</h2>
	<table>
		<tr>
			<th>Declaration</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>CBaseEntity@ CreateEntity(const string& in szClassName, dictionary@ pDictionary = null, bool fSpawn = true)</td>
			<td>Create an entity by class name. Pass keyvalues in using the dictionary, if any. Keyvalues must be strings.<br>The class name can be either one of the entities included with the game or a custom entity.</td>
		</tr>
		<tr>
			<td>CBaseEntity@ Create(const string& in szClassname, const Vector& in vecOrigin, const Vector& in vecAngles, bool fCreateAndDontSpawn, edict_t@ entOwner = null)</td>
			<td>Creates an entity by class name.</td>
		</tr>
		<tr>
			<td>void CreateDecal(const string& in szDecalName, const Vector& in vecOrigin, const string& in szTargetName = "")</td>
			<td>Creates a decal with the specified name.<br>If given a name, has to be triggered to be placed, otherwise, is placed immediately.</td>
		</tr>
		<tr>
			<td>CSprite@ CreateSprite(const string& in szSpriteName, const Vector& in vecOrigin, bool fAnimated, float flFrameRate = 10.0f)</td>
			<td>Creates a sprite. flFrameRate must be set to a valid value to animate the sprite.</td>
		</tr>
		<tr>
			<td>CBeam@ CreateBeam(const string& in szSpriteName, int width)</td>
			<td>Creates a beam entity with the given sprite and width set.</td>
		</tr>
		<tr>
			<td>void CreateExplosion(const Vector& in vecCenter, const Vector& in vecAngles, edict_t@ pOwner, int iMagnitude, bool fDoDamage)</td>
			<td>Creates an explosion.<br>If fDoDamage is true, also deals damage to entities within its effect radius, which is determined by the magnitude.</td>
		</tr>
		<tr>
			<td>CBaseEntity@ CreateDisplacerPortal(const Vector& in vecOrigin, const Vector& in vecVelocity, edict_t@ pOwner, float flDamage, float flRadius)</td>
			<td>Creates a displacer portal.</td>
		</tr>
		<tr>
			<td>CBaseEntity@ CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, edict_t@ pOwner)</td>
			<td>Creates an rpg rocket.</td>
		</tr>
		<tr>
			<td>CBaseEntity@ CreateRPGRocket(const Vector& in vecOrigin, const Vector& in vecAngles, const Vector& in vecVelocity, edict_t@ pOwner)</td>
			<td>Creates an rpg rocket with custom velocity.</td>
		</tr>
		<tr>
			<td>CGib@ CreateGib( const Vector& in vecOrigin, const Vector& in vecAngles)</td>
			<td>Creates a server side gib.</td>
		</tr>
		<tr>
			<td>CGrenade@ ShootTimed(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity, float flTime)</td>
			<td>Spawns a timed grenade.</td>
		</tr>
		<tr>
			<td>CGrenade@ ShootContact(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)</td>
			<td>Spawns a contact grenade.</td>
		</tr>
		<tr>
			<td>CGrenade@ ShootMortar(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)</td>
			<td>Spawns a mortar grenade.</td>
		</tr>
		<tr>
			<td>CGrenade@ ShootBananaCluster(entvars_t@ pevOwner, const Vector& in vecStart, const Vector& in vecVelocity)</td>
			<td>Spawn a banana bomb.</td>
		</tr>
		<tr>
			<td>void UseSatchelCharges(entvars_t@ pevOwner, SATCHELCODE code)</td>
			<td>Triggers all satchel charges owned by pevOwner to either be released from ownership, or detonated.</td>
		</tr>
		<tr>
			<td>void SpawnHeadGib(entvars_t@ pevVictim)</td>
			<td>Spawns a head gib for the target victim.</td>
		</tr>
		<tr>
			<td>void SpawnRandomGibs(entvars_t@ pevVictim, int cGibs, int iHuman)</td>
			<td>Spawns random gibs for the target victim.<br>iHuman specifies whether the gibs are human or alien.</td>
		</tr>
		<tr>
			<td>void SpawnStickyGibs(entvars_t@ pevVictim, const Vector& in vecOrigin, int cGibs)</td>
			<td>Spawns sticky gibs for the target victim.<br>cGibs specifies how many gibs there are.</td>
		</tr>
		<tr>
			<td>void SetOrigin(CBaseEntity@ entity, const Vector& in vecOrigin)</td>
			<td>Set the origin of an entity</td>
		</tr>
		<tr>
			<td>void SetModel(CBaseEntity@ entity, const string& in szFileName)</td>
			<td>Set the model of an entity</td>
		</tr>
		<tr>
			<td>void SetSize(entvars_t@ pev, const Vector& in vecMin, const Vector& in vecMax)</td>
			<td>Set the size of an entity</td>
		</tr>
		<tr>
			<td>CBaseEntity@ FindEntityInSphere(CBaseEntity@ pStartEntity, const Vector& in vecCenter, float flRadius,const string& in szValue = "", const string& in szKeyword = "targetname")</td>
			<td>Finds an entity in a sphere</td>
		</tr>
		<tr>
			<td>CBaseEntity@ FindEntityByString(CBaseEntity@ pStartEntity,const string& in szKeyword, const string& in szValue)</td>
			<td>Finds an entity based on a key value pair</td>
		</tr>
		<tr>
			<td>CBaseEntity@ FindEntityByClassname(CBaseEntity@ startEntity, const string& in name)</td>
			<td>Finds an entity by class name</td>
		</tr>
		<tr>
			<td>CBaseEntity@ FindEntityByTargetname(CBaseEntity@ startEntity, const string& in name)</td>
			<td>Finds an entity by target name</td>
		</tr>
		<tr>
			<td>CBaseEntity@ FindEntityGeneric(const string& in szName, const Vector& in vecSrc, float flRadius)</td>
			<td>Finds an entity by target name in a sphere</td>
		</tr>
		<tr>
			<td>int MonstersInSphere(array&lt;CBaseEntity@&gt;@ pArray, const Vector& in vecCenter, float flRadius)</td>
			<td>Finds monsters in a sphere</td>
		</tr>
		<tr>
			<td>int EntitiesInBox(array&lt;CBaseEntity@&gt;@ pArray, const Vector& in mins, const Vector& in maxs, int flagMask)</td>
			<td>Finds entities in a box</td>
		</tr>
		<tr>
			<td>int TargetsInBox(array&lt;CBaseEntity@&gt;@ pArray, const Vector& in mins, const Vector& in maxs)</td>
			<td>Finds targets in a box</td>
		</tr>
		<tr>
			<td>int BrushEntsInBox(array&lt;CBaseEntity@&gt;@ pArray, const Vector& in mins, const Vector& in maxs )</td>
			<td>Finds brush entities in a box</td>
		</tr>
		<tr>
			<td>int DispatchSpawn(edict_t@ entity)</td>
			<td>Dispatches the spawning of an entity</td>
		</tr>
		<tr>
			<td>bool DispatchKeyValue(edict_t@ entity, const string& in szKeyName, const string& in szValue)</td>
			<td>Dispatches the passing of a key value pair to an entity</td>
		</tr>
		<tr>
			<td>bool EntvarsKeyvalue(edict_t@ entity, const string& in szKeyName, const string& in szValue)</td>
			<td>Handles the initialization of keyvalues located in the entity's entvars_t object.</td>
		</tr>
		<tr>
			<td>void DispatchObjectCollisionBox(edict_t@ entity)</td>
			<td>Dispatches the initialization of the collision box of an entity</td>
		</tr>
		<tr>
			<td>CBaseEntity@ Instance(edict_t@ edict)</td>
			<td>Gets the entity instance of an edict instance</td>
		</tr>
		<tr>
			<td>CBaseEntity@ Instance(entvars_t@ vars)</td>
			<td>Gets the entity instance of an entvars instance</td>
		</tr>
		<tr>
			<td>CBaseEntity@ Instance(int iEdictNum)</td>
			<td>Gets the entity instance based on an edict number</td>
		</tr>
		<tr>
			<td>void FireTargets(const string& in szTargetName, CBaseEntity@ pActivator, CBaseEntity@ pCaller, USE_TYPE useType, float flValue = 0.0f, float flDelay = 0.0f)</td>
			<td>Triggers targets. If flDelay is nonzero, causes a temporary entity to be spawned to trigger the target at the given time.<br>The temporary entity becomes the caller, not the entity passed in.</td>
		</tr>
		<tr>
			<td>bool IsMasterTriggered(const string& in szMaster, CBaseEntity@ pActivator)</td>
			<td>Returns whether the master with the given name would be triggered if activated by the given entity.</td>
		</tr>
		<tr>
			<td>void Remove(CBaseEntity@ pEntity)</td>
			<td>Removes the given entity before the next frame starts.</td>
		</tr>
		<tr>
			<td>bool IsValidEntity(edict_t@ pEntity)</td>
			<td>Returns whether this is a valid entity.</td>
		</tr>
		<tr>
			<td>int EntIndex(edict_t@ pEdict)</td>
			<td>Gets the index for the given edict.</td>
		</tr>
		<tr>
			<td>edict_t@ IndexEnt(int iEdictNum)</td>
			<td>Gets the edict for the given index.</td>
		</tr>
		<tr>
			<td>void EjectBrass(const Vector& in vecOrigin, const Vector& in vecVelocity, float flRotation, int iModel, TE_BOUNCE soundtype)</td>
			<td>tosses a brass shell from passed origin at passed velocity.</td>
		</tr>
		<tr>
			<td>ScriptClassInterface@ CastToScriptClass(CBaseEntity@ pEntity)</td>
			<td>Casts an CBaseEntity@ representing a custom entity to the ScriptClassBaseClass type</td>
		</tr>
		<tr>
			<td>CBaseEntity@ RandomTargetname(const string& in szTargetname)</td>
			<td>Returns a randomly selected entity that has the given target name.</td>
		</tr>
		<tr>
			<td>void PrecacheMaterialSounds(const Materials material)</td>
			<td>Precaches the sounds used by a particular material</td>
		</tr>
	</table>
	</div>
</body>
</html>
