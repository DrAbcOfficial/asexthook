<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
	<meta name="generator" content="ASDocGenerator 1.1">
	<meta name="description" content="Functions that are accessible at a global level.">
	<meta property="og:title" content="Functions">
	<meta property="og:description" content="Functions that are accessible at a global level.">
	<meta property="og:type" content="website">
	<meta property="og:image" content="https://github.com/baso88/SC_AngelScript/wiki/images/sc_as_logo_media.png">
	<meta property="og:site_name" content="Sven Co-op AngelScript API">
	<link rel="stylesheet" type="text/css" href="doc.css">
	<title>Functions</title>
</head>
<body>
	<div><h1>Global Functions</h1>
	<p>Functions that are accessible at a global level.</p>
	</div>
	<div><h2>Functions</h2>
	<table>
		<tr>
			<th>Namespace</th>
			<th>Declaration</th>
			<th>Description</th>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isalnum(char character)</td>
			<td>Returns whether character is alphanumeric.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isalpha(char character)</td>
			<td>Returns whether character is alphabetic.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool iscntrl(char character)</td>
			<td>Returns whether character is control.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isdigit(char character)</td>
			<td>Returns whether character is a decimal digit character.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isgraph(char character)</td>
			<td>Returns whether character is graph.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool islower(char character)</td>
			<td>Returns whether character is lower.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isprint(char character)</td>
			<td>Returns whether character is print.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool ispunct(char character)</td>
			<td>Returns whether character is punctuality.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isspace(char character)</td>
			<td>Returns whether character is space.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isupper(char character)</td>
			<td>Returns whether character is upper.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isxdigit(char character)</td>
			<td>Returns whether character is a hexadecimal numeric character.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>char tolower(char character)</td>
			<td>Converts the given character to lower case.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>char toupper(char character)</td>
			<td>Converts the given character to upper case.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>float atof(const string& in)</td>
			<td>Converts the given string to a float.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>double atod(const string& in)</td>
			<td>Converts the given string to a double.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>int atoi(const string& in, int radix = 10)</td>
			<td>Converts the given string to an integer.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>int64 atoi64(const string& in, int radix = 10)</td>
			<td>Converts the given string to a 64 bit integer.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>uint atoui(const string& in, int radix = 10)</td>
			<td>Converts the given string to an unsigned integer.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>uint64 atoui64(const string& in, int radix = 10)</td>
			<td>Converts the given string to a 64 bit unsigned integer.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool atobool(const string& in)</td>
			<td>Converts the given string to a boolean.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool atobool(const string& in, bool& out fIsValid)</td>
			<td>Converts the given string to a boolean. fIsValid is true if the given string was a valid boolean value.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isalnum(const string& in)</td>
			<td>Returns whether character is alphanumeric.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isalpha(const string& in)</td>
			<td>Returns whether character is alphabetic.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool iscntrl(const string& in)</td>
			<td>Returns whether character is control.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isdigit(const string& in)</td>
			<td>Returns whether character is digit.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isgraph(const string& in)</td>
			<td>Returns whether character is graph.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool islower(const string& in)</td>
			<td>Returns whether character is lower.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isprint(const string& in)</td>
			<td>Returns whether character is print.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool ispunct(const string& in)</td>
			<td>Returns whether character is punctuality.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isspace(const string& in)</td>
			<td>Returns whether character is space.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isupper(const string& in)</td>
			<td>Returns whether character is upper.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool isxdigit(const string& in)</td>
			<td>Returns whether character is xdigit.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>string tolower(const string& in)</td>
			<td>Converts the given character to lower case.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>string toupper(const string& in)</td>
			<td>Converts the given character to upper case.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>string formatInt(int64 value, const string &in options = "", uint width = 0)</td>
			<td>Formats a signed integer into a string.<br>The options string is a combination of the following characters:<br>'l' = left justify<br>'0' = pad with zeroes<br>'+' = always include the sign, even if positive<br>' ' = add a space in case of positive number<br>'h' = hexadecimal integer small letters<br>'H' = hexadecimal integer capital letters<br></td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>string formatUInt(uint64 value, const string &in options = "", uint width = 0)</td>
			<td>Formats a unsigned integer into a string.<br>The options string is a combination of the following characters:<br>'l' = left justify<br>'0' = pad with zeroes<br>'+' = always include the sign, even if positive<br>' ' = add a space in case of positive number<br>'h' = hexadecimal integer small letters<br>'H' = hexadecimal integer capital letters<br></td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>string formatFloat(double value, const string &in options = "", uint width = 0, uint precision = 0)</td>
			<td>Formats a double into a string.<br>The options string is a combination of the following characters:<br>'l' = left justify<br>'0' = pad with zeroes<br>'+' = always include the sign, even if positive<br>' ' = add a space in case of positive number<br>'e' = exponent character with small e<br>'E' = exponent character with capital E<br></td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool snprintf(string& out szOutBuffer, const string& in szFormat, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in, ?& in)</td>
			<td>Prints the format string to the destination buffer. Uses SC printf formatting style.</td>
		</tr>
		<tr>
			<td>Regex</td>
			<td>bool Match(const string& in szString, const Regex@ pRegex, MatchFlagType flags = match_default)</td>
			<td>Performs are regular expression matching operation.<br>Returns true if the match succeeded, false otherwise</td>
		</tr>
		<tr>
			<td>Regex</td>
			<td>bool Match(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = match_default)</td>
			<td>Performs are regular expression matching operation.<br>Returns true if the match succeeded, false otherwise.<br>pResults will contain the results of the operation, if any.</td>
		</tr>
		<tr>
			<td>Regex</td>
			<td>bool Search(const string& in szString, const Regex@ pRegex, MatchFlagType flags = match_default)</td>
			<td>Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex.</td>
		</tr>
		<tr>
			<td>Regex</td>
			<td>bool Search(const string& in szString, MatchResults@ pResults, const Regex@ pRegex, MatchFlagType flags = match_default)</td>
			<td>Returns whether some sub-sequence in the target sequence (the subject) matches the regular expression pRegex.<br>pResults will contain the results of the operation, if any.</td>
		</tr>
		<tr>
			<td>Regex</td>
			<td>string Replace(const string& in szString, const Regex@ pRegex, const string& in szFormat, MatchFlagType flags = match_default)</td>
			<td>Makes a copy of the target sequence (the subject) with all matches of the regular expression pRegex (the pattern) replaced by szFormat (the replacement).</td>
		</tr>
		<tr>
			<td>FileSystem</td>
			<td>bool FlagsValid(const OpenFileFlags_t uiOpenFlags)</td>
			<td>Returns whether the given open flags are valid.</td>
		</tr>
		<tr>
			<td>FileSystem</td>
			<td>OpenFileFlags_t FilterFlags(OpenFileFlags_t uiOpenFlags)</td>
			<td>Filters the given flags, removing unnecessary flags.</td>
		</tr>
		<tr>
			<td>FileSystem</td>
			<td>bool FormatOpenFlags(OpenFileFlags_t uiOpenFlags, string& out szOutFlags)</td>
			<td>Formats the open flags into a string that represents the flags.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>CScheduler@ get_g_Scheduler()</td>
			<td>Gets the current script's scheduler.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>float DotProduct(const Vector2D& in lhs, const Vector2D& in rhs)</td>
			<td>Returns a dot product of the given vectors</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>float DotProduct(const Vector& in lhs, const Vector& in rhs)</td>
			<td>Returns the dot product of the given vectors</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>Vector CrossProduct(const Vector& in, const Vector& in)</td>
			<td>Returns the cross product of the given vectors</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>int TrainSpeed(int iSpeed, int iMax)</td>
			<td></td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool FNullEnt(const edict_t@ pEnt)</td>
			<td>Checks edict for nullity</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>bool FNullEnt(entvars_t@ pev)</td>
			<td>Checks entvars for nullity</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>CSoundEnt@ GetSoundEntInstance()</td>
			<td>Gets the current global sound manager entity</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>CPathTrack@ PathTrackEntity_Instance(edict_t@ pEdict)</td>
			<td></td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>CPersistence@ get_g_Persistence()</td>
			<td>Gets the map script's persistence manager.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>time_t UnixTimestamp()</td>
			<td>Gets the current time as a unix timestamp.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>CModuleHookManager@ get_g_Hooks()</td>
			<td>Gets the current script's hook manager.</td>
		</tr>
		<tr>
			<td>&lt;Global&gt;</td>
			<td>CModule@ get_g_Module()</td>
			<td>Gets the current script's module.</td>
		</tr>
	</table>
	</div>
</body>
</html>
